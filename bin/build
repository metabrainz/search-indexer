#!/bin/bash

echo "$0 starting"

SEARCH_HOME=/home/search
SEARCH_PUSH_TO="dora roobarb"
SEARCH_PUSH_TO_DELAY=300

SEARCH_REC_HOUR=1
SEARCH_REC_MAX_HOUR=12
SEARCH_REC_THRESHOLD=$((12*3600))

SEARCH_FREEDB_DAY=2
SEARCH_FREEDB_HOUR=4
SEARCH_FREEDB_MAX_HOUR=12
SEARCH_FREEDB_THRESHOLD=86400 # 24 hours

SEARCH_INDEXER_PAUSE_DELAY=60

SEARCH_CONFIG="$HOME/mb_search_server.conf"
[ -e "$SEARCH_CONFIG" ] && . "$SEARCH_CONFIG"

echo "SEARCH_HOME=$SEARCH_HOME SEARCH_PUSH_TO=$SEARCH_PUSH_TO"
cd $SEARCH_HOME || exit 1

NOW=`date +%s`
DAY=`date +%d`
HOUR=`date +%H`

STATUSDIR="$SEARCH_HOME/indexer"
[ ! -d "$STATUSDIR" ] && mkdir -p "$STATUSDIR"

# store time of last updates
REC_TIMESTAMP_FILE="$STATUSDIR/.recording_build_timestamp"
FREEDB_TIMESTAMP_FILE="$STATUSDIR/.freedb_build_timestamp"

# when this file exists, freedb index will be built, without other conditions,
# the file will be removed when it starts
REC_BUILD_FORCE="$STATUSDIR/force_recording"

# when this file exists, freedb index will be built, without other conditions,
# the file will be removed when it starts
FREEDB_BUILD_FORCE="$STATUSDIR/force_freedb"

# existence of this file will pause the indexer
PAUSE_INDEXER_FILE="$STATUSDIR/pause"

# existence of this file will disable any push
NO_PUSH_FILE="$STATUSDIR/no_push"

# this file is created at the end of index generation and remove after pushs
# indexer will not restart while it exists
READYFILE="$SEARCH_HOME/data/cur/UPDATE_READY"

# compatibility with older versions
for FILE in recording_build_timestamp freedb_build_timestamp; do
	[ -e "$STATUSDIR/.$FILE" ] && continue
	if [ -e "$SEARCH_HOME/$FILE" ]; then
		mv -v "$SEARCH_HOME/$FILE" "$STATUSDIR/.$FILE"
	fi
done


if [ -e "$PAUSE_INDEXER_FILE" ]; then
	echo "Indexer PAUSED ($PAUSE_INDEXER_FILE exists)."
	echo "Sleeping $SEARCH_INDEXER_PAUSE_DELAY seconds before next check."
	sleep $SEARCH_INDEXER_PAUSE_DELAY
	exit 0
fi

if [ ! -f $REC_TIMESTAMP_FILE ]; then
	echo $(($NOW - $SEARCH_REC_THRESHOLD)) > $REC_TIMESTAMP_FILE
fi
REC_LAST_BUILD=`cat $REC_TIMESTAMP_FILE`
REC_ELAPSED=`expr $NOW - $REC_LAST_BUILD`

if [ ! -f $FREEDB_TIMESTAMP_FILE ]; then
	echo $(($NOW - $SEARCH_FREEDB_THRESHOLD)) > $FREEDB_TIMESTAMP_FILE
fi
FREEDB_LAST_BUILD=`cat $FREEDB_TIMESTAMP_FILE`
FREEDB_ELAPSED=`expr $NOW - $FREEDB_LAST_BUILD`

# if cur isn't a symlink, we run once to prepare the dirs and links
[ ! -L data/cur ] && (cd data && $SEARCH_HOME/bin/safe_dir_rotation)

if [ ! -e "$READYFILE" ]; then

	echo "Clean up old files"
	! rm -rf data/new/*

	run_and_show_errors() {
		echo "Running $@"
		if ! "$@"
		then
			RC=$?
			echo "FAIL '$@' (rc=$RC)"
			return 1
		else
			echo "PASS '$@'"
			return 0
		fi
	}

	build_freedb_index() {
		if [ -f "$FREEDB_BUILD_FORCE" ]; then
			echo "Building freedb index (forced)"
			rm -f "$FREEDB_BUILD_FORCE"
			return 0
		fi
		if [ "$FREEDB_ELAPSED" -lt "$SEARCH_FREEDB_THRESHOLD" ]; then
			echo "Not building freedb index ($FREEDB_ELAPSED of $SEARCH_FREEDB_THRESHOLD seconds since last freedb build)."
			return 1
		fi
		if [ "$DAY" -ne "$SEARCH_FREEDB_DAY" ]; then
			echo "Not building freedb index (only on day $SEARCH_FREEDB_DAY)."
			return 1
		fi
		if [ "$HOUR" -lt "$SEARCH_FREEDB_HOUR" ] || [ "$HOUR" -gt "$SEARCH_FREEDB_MAX_HOUR" ]; then
			echo "Not building freedb index (only between $SEARCH_FREEDB_HOUR and $SEARCH_FREEDB_MAX_HOUR hours)."
			return 1
		fi
		echo "Building freedb index. Last index was started $FREEDB_ELAPSED seconds ago"
		return 0
	}

	if build_freedb_index; then
		START=$(date +%s)
		run_and_show_errors make freedb || exit 2
		echo "$START" > $FREEDB_TIMESTAMP_FILE
	fi

	build_recording_index() {
		if [ -f "$REC_BUILD_FORCE" ]; then
			echo "Building recording index (forced)"
			rm -f "$REC_BUILD_FORCE"
			return 0
		fi
		if [ "$REC_ELAPSED" -lt "$SEARCH_REC_THRESHOLD" ]; then
			echo "Not building recording index ($REC_ELAPSED of $SEARCH_REC_THRESHOLD seconds since last recording build)."
			return 1
		fi
		if [ "$HOUR" -lt "$SEARCH_REC_HOUR" ] || [ "$HOUR" -gt "$SEARCH_REC_MAX_HOUR" ]; then
			echo "Not building recording index (only between $SEARCH_REC_HOUR and $SEARCH_REC_MAX_HOUR hours)."
			return 1
		fi
		echo "Building recording index. Last index was started $REC_ELAPSED seconds ago"
		return 0
	}

	if build_recording_index; then
		START=$(date +%s)
		run_and_show_errors make recording || exit 2
		echo "$START" > $REC_TIMESTAMP_FILE
	fi

	run_and_show_errors make || exit 2

	echo "Rotate generated indexes"
	(cd data && safe_dir_rotation) || exit 1

	touch $READYFILE
else
	echo "Skipping build indexes because $READYFILE exists."
fi

if [ ! -e "$NO_PUSH_FILE" ]; then
	if [ ! -z "$SEARCH_PUSH_TO" ]; then
		echo "Pushing to remote search servers"
		for SERVER in $SEARCH_PUSH_TO
		do
			# append localdomain if server name has no dot
			echo -n "$SERVER" |grep -qF '.' || SERVER=${SERVER}.localdomain
			run_and_show_errors push-to-server $SERVER sync
			if [ $? = 0 ]; then
				run_and_show_errors push-to-server $SERVER rotate
				if [ $? = 0 ]; then
					run_and_show_errors push-to-server $SERVER restart \
				fi
			fi
			sleep $SEARCH_PUSH_TO_DELAY
		done
	fi

	# if the indexer server is also a search server
	if [ -e "$SEARCH_HOME/is_search_server" ]; then
		echo "Restarting local search server"
		$SEARCH_HOME/bin/restart_search_server
	fi
else
	echo "Push disabled ($NO_PUSH_FILE exists)"
fi

rm -f $READYFILE || echo "Failed to remove $READYFILE"

echo "$0 completed"

# eof
